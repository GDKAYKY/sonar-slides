import os
import requests
import pandas as pd
from datetime import datetime
from flask import Flask, jsonify, request, send_from_directory
from dotenv import load_dotenv

# Carregar variáveis do arquivo config.env com caminho absoluto
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
ENV_PATH = os.path.join(BASE_DIR, "config.env")
load_dotenv(ENV_PATH)

# filepath: c:\repos\sonar-slides\main.py
# ...existing code...
SONARQUBE_TOKEN = os.getenv("SONARQUBE_TOKEN")
print("TOKEN:", repr(SONARQUBE_TOKEN))  # <-- Adicione esta linha para depurar
SONAR_URL = os.getenv("SONARQUBE_URL", "https://sonar.prd.whoid.com/api/measures/component")
SONAR_HISTORY_URL = os.getenv("SONAR_HISTORY_URL", "https://sonar.prd.whoid.com/api/measures/search_history")
SONAR_VERIFY = os.getenv("SONAR_VERIFY", "true").lower() in {"1", "true", "yes", "on"}
SONAR_DEFAULT_BRANCH = os.getenv("SONAR_DEFAULT_BRANCH", "main")

METRICS = "bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density,security_hotspots,reliability_rating,security_rating,sqale_rating"

app = Flask(__name__)

def get_auth():
    """Retorna tupla para Basic Auth se token estiver configurado."""
    return (SONARQUBE_TOKEN, "") if SONARQUBE_TOKEN else None

def request_sonarqube_api(url, params):
    """Faz requisição GET ao SonarQube com tratamento de erros."""
    try:
        response = requests.get(url, params=params, auth=get_auth(), timeout=30, verify=SONAR_VERIFY)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.Timeout:
        app.logger.error("Timeout na requisição SonarQube.")
        raise
    except requests.exceptions.ConnectionError as e:
        app.logger.error(f"Erro de conexão SonarQube: {e}")
        raise
    except requests.HTTPError as http_err:
        app.logger.error(f"Erro HTTP SonarQube: {http_err.response.status_code} - {http_err.response.text}")
        raise
    except Exception as err:
        app.logger.error(f"Erro inesperado: {err}")
        raise

def format_percentage(value):
    try:
        return f"{float(value):.1f}%"
    except (TypeError, ValueError):
        return "0.0%"

def get_project_measures(project_key, branch=None):
    branch = branch or SONAR_DEFAULT_BRANCH
    params = {
        "component": project_key,
        "metricKeys": METRICS,
        "branch": branch,
    }
    payload = request_sonarqube_api(SONAR_URL, params)
    measures = payload.get("component", {}).get("measures", [])
    metrics_map = {m.get("metric"): m.get("value") for m in measures}

    return {
        "projeto": project_key,
        "data_consulta": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "bugs": int(float(metrics_map.get("bugs", 0))),
        "vulnerabilidades": int(float(metrics_map.get("vulnerabilities", 0))),
        "code_smells": int(float(metrics_map.get("code_smells", 0))),
        "security_hotspots": int(float(metrics_map.get("security_hotspots", 0))),
        "coverage": format_percentage(metrics_map.get("coverage", 0)),
        "duplicacoes": format_percentage(metrics_map.get("duplicated_lines_density", 0)),
        "reliability_rating": metrics_map.get("reliability_rating", "N/A"),
        "security_rating": metrics_map.get("security_rating", "N/A"),
        "sqale_rating": metrics_map.get("sqale_rating", "N/A"),
    }

def get_project_history(project_key, metric, from_date=None, to_date=None, branch=None):
    branch = branch or SONAR_DEFAULT_BRANCH
    params = {
        "component": project_key,
        "metrics": metric,
        "ps": 100,
        "branch": branch,
    }
    if from_date:
        params["from"] = from_date
    if to_date:
        params["to"] = to_date

    payload = request_sonarqube_api(SONAR_HISTORY_URL, params)
    return payload.get("measures", [])

def export_sonarqube_data(project_key, from_date=None, to_date=None, filename=None):
    filename = filename or f"sonarqube_export_{project_key}_{datetime.now():%Y%m%d_%H%M%S}.xlsx"

    current_data = get_project_measures(project_key)
    historical_metrics = ["bugs", "vulnerabilities", "code_smells"]
    historical_data = []

    for metric in historical_metrics:
        try:
            history = get_project_history(project_key, metric, from_date, to_date)
            for measure in history:
                for value in measure.get("history", []):
                    historical_data.append({
                        "projeto": project_key,
                        "metrica": metric,
                        "data": value.get("date", ""),
                        "valor": value.get("value", 0),
                    })
        except Exception as e:
            app.logger.error(f"Erro ao obter histórico para {metric}: {e}")

    with pd.ExcelWriter(filename, engine='openpyxl') as writer:
        pd.DataFrame([current_data]).to_excel(writer, sheet_name='Dados_Atuais', index=False)

        if historical_data:
            df_history = pd.DataFrame(historical_data)
            df_history.to_excel(writer, sheet_name='Historico_Temporal', index=False)

            df_summary = df_history.groupby(['projeto', 'metrica']).agg({
                'valor': ['min', 'max', 'mean', 'last']
            }).round(2)
            df_summary.columns = ['Valor_Min', 'Valor_Max', 'Valor_Medio', 'Valor_Atual']
            df_summary.reset_index().to_excel(writer, sheet_name='Resumo_Periodo', index=False)

    app.logger.info(f"Exportação concluída: {filename}")
    return filename

def consultar_sonarqube_period(project_key, from_date, to_date, branch=None):
    branch = branch or SONAR_DEFAULT_BRANCH
    from_str = from_date if isinstance(from_date, str) else from_date.strftime("%Y-%m-%d")
    to_str = to_date if isinstance(to_date, str) else to_date.strftime("%Y-%m-%d")

    current_data = get_project_measures(project_key, branch=branch)
    metrics = ["bugs", "vulnerabilities", "code_smells"]
    history = {}

    for metric in metrics:
        try:
            history[metric] = get_project_history(project_key, metric, from_str, to_str, branch=branch)
        except Exception:
            history[metric] = []

    return {
        "projeto": project_key,
        "periodo": {"de": from_str, "ate": to_str},
        "dados_atuais": current_data,
        "historico_periodo": history,
    }

@app.route('/static/<path:path>')
def send_static(path):
    return send_from_directory('static', path)

@app.route('/')
def index():
    return send_from_directory('static', 'index.html')

@app.route('/api/projeto/<project_key>')
def api_project(project_key):
    branch = request.args.get('branch', SONAR_DEFAULT_BRANCH)
    try:
        data = get_project_measures(project_key, branch)
        return jsonify(data)
    except requests.RequestException as e:
        return jsonify({"error": str(e)}), 502
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/medidas')
def api_measures():
    component = request.args.get('component')
    if not component:
        return jsonify({"error": "Parâmetro 'component' é obrigatório"}), 400

    metric_keys = request.args.get('metricKeys', METRICS)
    branch = request.args.get('branch', SONAR_DEFAULT_BRANCH)

    params = {"component": component, "metricKeys": metric_keys, "branch": branch}

    try:
        payload = request_sonarqube_api(SONAR_URL, params)
        return jsonify(payload)
    except requests.RequestException as e:
        return jsonify({"error": str(e)}), 502
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/exportar/<project_key>')
def api_export(project_key):
    from_date = request.args.get('from_date')
    to_date = request.args.get('to_date')
    try:
        filename = export_sonarqube_data(project_key, from_date, to_date)
        return jsonify({"success": True, "arquivo": filename, "mensagem": "Exportação concluída com sucesso"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/consultar_periodo/<project_key>')
def api_consultar_period(project_key):
    from_date = request.args.get('from_date')
    to_date = request.args.get('to_date')

    if not from_date or not to_date:
        return jsonify({"error": "Parâmetros from_date e to_date são obrigatórios"}), 400

    try:
        result = consultar_sonarqube_period(project_key, from_date, to_date)
        return jsonify(result)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True, port=8080)
